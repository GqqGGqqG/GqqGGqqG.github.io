{"pages":[{"title":"分类","text":"","link":"/categories/index.html"},{"title":"about","text":"NEWS简介标准小镇做题家， 间歇性踌躇满志， 专业表演退堂鼓，AKA talked five 学历2014-2017 高中 江西省九江市庐山市一中 理科（rank1） 2017-2021 本科 武汉大学计算机学院 软件工程（3.875/4.0 8/58 14/316） 2021-202? 硕士 武汉大学计算机学院 计算机科学与技术 获奖2017-2018 武汉大学国家励志奖学金 武汉大学优秀本科生丙等奖学金 2018-2019 武汉大学国家励志奖学金 武汉大学优秀本科生丙等奖学金 2019-2020 武汉大学国家励志奖学金 武汉大学优秀本科生丙等奖学金 联系Github: https://github.com/GqqGGqqG LeetCode: https://leetcode-cn.com/u/gqqggqqg/ AcWing: https://www.acwing.com/user/myspace/index/91541/ Codeforces: https://codeforces.com/profile/GqqG Email: gqzooo@qq.com QQ: 884427437","link":"/about/index.html"}],"posts":[{"title":"21-04-刷题","text":"主要内容： acwing, 数组，字符串，基础课 如何导入一行的变量 123int a，b;cin&gt;&gt;a&gt;&gt;b;//input &quot;2 3&quot; 如何导入多维数组 1234567891011int li[n][m];for(int i = 0;i&lt;n;i++){ for(int j= 0;j&lt;m;j++){ scanf(&quot;%d&quot;,&amp;li[i][j]); //cin&gt;&gt;li[i][j] 也可以 }}//input//1 2 3//4 5 6//7 8 9 如何使用pow 1234#include&lt;cmath&gt;//等价于#include&lt;math.h&gt;int a = pow(3,2)//3**2 = 9 多行数字输入，以0时结束 123456789int n;while(cin&gt;&gt;n,n){ //0 为false 故不会进入 cout&lt;&lt;n&lt;&lt;endl;}//input //1//2//0 初始化问题 全局变量数组随机初始化时会为0 函数内数组随机初始化为随机 但是可以像一维数组一样对二维数组初始化 12345678910111213141516171819202122#include&lt;iostream&gt;using namespace std;int li_a[3][3];int main(){ int li_b[3][3]; //int li_b[3][3] = {0}; 这样结果就是对的 for(int i=0;i&lt;3;i++){ for(int j=0;j&lt;3;j++){ printf(&quot;%12d&quot;,li_a[i][j]); //all will be equal to 0 } cout&lt;&lt;endl; } cout&lt;&lt;endl; for(int i=0;i&lt;3;i++){ for(int j=0;j&lt;3;j++){ printf(&quot;%12d&quot;,li_b[i][j]); //random(int) } cout&lt;&lt;endl; }} c++字符串的初始化 1234char s[] = {'a','b','c'};char s1[] = {'a','b','c','\\0'};char s2[] = &quot;abc&quot;;//结果是一样的 c++字符串的读入输出 123456789101112131415161718192021222324char s[4];//读入以 空格或回车为结束cin&gt;&gt;s;cin&gt;&gt;s+1;//因为是指针，不需要引用scanf(&quot;%s&quot;,s);//从某个下标读取 ,cpp的指针运算机制scanf(&quot;%s&quot;,s+1);//空格同时读入 1000000为最多读入多少字符//字符数组fgets(s,10000000,stdin);cin.getline(s,10000000);//string#include&lt;cstring&gt;string str;getline(cin,str);;//输出cout&lt;&lt;s;cout&lt;&lt;s+1;printf(&quot;%s&quot;,s);//从某一下标开始输出printf(&quot;%s&quot;,s+1); 字符串常见操作 仅对于char数组 123456789//string.h/cstring#include&lt;string.h&gt;#include&lt;cstring&gt;//返回数组长度strlen(str);//比较字典序 若str1&lt;str2 -1 == 0 &gt;1strcmp(str1,str2);//char数组拷贝 把b拷贝给astrcp(a,b); segment fault 12345char c;//会出错，因为类型不对printf(&quot;%s&quot;,c);//correctionprintf(&quot;%c&quot;,c); 本质上的区别 读到回车时下面会多读一次，i会再次加一 12while(cin&gt;&gt;a[i]) i++;while(cin&gt;&gt;a[i++]); 字符串的操作 1234567string s;s.size();s.length();//从下标0开始，截取s.size()-个字符s.substr(0,s.size()-1);//从下标5开始，一直到结束s.substr(5); ACWING \\777. 字符串乘方 https://www.acwing.com/problem/content/779/ 字符串长度n 枚举n的约数 再将可能的排列扩大到n，判断是否与原字符串相等。 人家的代码写的多好看啊~ ACWING \\778. 字符串最大跨距 https://www.acwing.com/problem/content/780/ 很有意思，自己写的很臭 如果用库函数肯定很快 记得str.size()返回的是一个unsigned int，做运算时会把int强转ui，要么把它转int，要么就特判。 函数定义 1234567891011121314151617181920//函数声明 可以不写变量名称 算法题一般用不到int foo(int);//函数定义 形参int foo(int n){//donothing//不写return时会随机返回数值}//默认参数 但是只能出现在后方并且连续int foo(int a,int b=10){}//random()cout&lt;&lt;foo();//实参int foo1(int &amp;n);int foo1(int &amp;n){} 静态变量的初始化只会在第一次被执行 和全局变量一样，都会被赋值为0 1234567//仅在函数内部能被访问到的全局变量int foo(){ static int cnt; cout&lt;&lt;cnt++&lt;&lt;endl;}foo()*5; AcWing \\808. 最大公约数 https://www.acwing.com/problem/content/810/ 12345678910111213141516171819202122//辗转相除int gcd(int a,int b){ if(a%b==0) return b; return gcd(b,a%b);}//非递归 可以加入判断大小swap()#include&lt;algorithm&gt;int gcd(int a,int b){ int tempt; while(a%b!=0){ tempt = a%b; a = b; b = tempt; } return b;}//双击666int gcd(int a,int b){ while(b^=a^=b^=a%=b); return a;} 多维数组的第一维的参数可以去掉 1234int foo(int li[][3][4]){ return 0;}foo(newli); sizeof对于数组参数的影响； 1234567891011121314#include&lt;iostream&gt;using namespace std;void foo(int b[]){ cout&lt;&lt;&quot;IN_FUNC &quot;&lt;&lt; sizeof(b)&lt;&lt;endl;}int main(){ int a[] = {1,2,3,4,5,6}; //sizeof a 是对的 cout&lt;&lt;&quot;IN_MAIN &quot;&lt;&lt; sizeof a&lt;&lt;endl; foo(a);}//IN_MAIN 24//IN_FUNC 8 快速排序 这是别人写的 边界分析 123456789101112//重点是特判、i，j的初始化 、以及边界处理，背！void quick_sort(int q[],int l,int r){ if(l&gt;=r)return; int i = l-1,j = r+1; int x = q[l+r&gt;&gt;1]; while(i&lt;j){ while(q[++i]&lt;x); while(q[--j]&gt;x); if(i&lt;j)swap(q[i],q[j]); } quick_sort(q,l,j);quick_sort(q,j+1,r);}","link":"/2021/04/26/21-04-%E5%88%B7%E9%A2%98/"},{"title":"快速排序实现与分析","text":"主要内容： 快速排序算法的实现与细节分析，参考 1234567891011//先上代码void quick_sort(int q[],int l,int r){ if (l&gt;=r)return; int i = l-1,j = r+1,x = q[l+r&gt;&gt;1]; while (i&lt;j){//eq3 while(q[++i]&lt;x);//eq1 while(q[--j]&gt;x);//eq2 if(i&lt;j)swap(q[i],q[j]); } quick_sort(q,l,j);quick_sort(q,j+1,r);} 输入分析：q[l~r] 输入的为数组指针q，从l开始到r结束的闭区间数组，对其中的元素进行排序 递归终止：if(l&gt;=r)return; 当输入的数组长度为0，1时，必定有序，则无需进行排序操作，防止了无限递归。 i，j初始化：int i = l-1,j = r+1; 将所有i，j可能的数值进行统一处理，而不必先判断当前的i是否为0。 小循环终止条件 while(q[++i]&lt;x); while(q[–j]&gt;x); ++i保证i会持续向后移动 当终止条件为&lt;=x时，会出现无限月读的情况，因为==x的元素永远不会移动 x取值 int x = q[l+r&gt;&gt;1]; 取中间保证不会受到有序的数组的特殊情况导致超时的现象 向下取整保证x的选取不会为q[r]（会出现无限月读），但数值可以相同 划分有效性证明：（l,j）(j+1,r)的划分中，lj为&lt;=x ,j+1r为&gt;=x 由eq1,eq2得 q[l,i-1]&lt;x and q[i]&gt;=x ① q[j+1,r]&gt;x and q[j]&lt;=x ② 由eq3得 i&gt;=j ③ 由①③有 q[l,i-1]&lt;x i&gt;=j ==&gt;&gt; i-1&gt;=j-1 q[l,j-1]&lt;x ④ 由④②有 q[l,j-1]&lt;x q[j]&lt;=x q[l,j]&lt;=x 恒成立 而 q[j+1,r]&gt;x ==》 q[j+1,r]&gt;=x （充分条件） 综上，故有 **q[l,j]&lt;=x q[j+1,r]&gt;=x **恒成立 划分正确性证明： j==r时出现的无限月读 当j==r时，右数组长度为0，故没有出现有效划分 而j==[l,r-1]时，至少都会划分出长度为1的数组，故有效 故需要验证不会出现无限月读，即划分结果中出现 j！=r，即j的值域需要映射在[l,r-1] 证明j&lt;r 当j==r时 根据上面的推论 q[r]&lt;=x i&gt;=j =&gt; i&gt;=r q[i]&gt;=x q[l,i-1]&lt;x q[r]&gt;=x q[l,r-1]&lt;x 故q[r] = x 而x = q[l+r&gt;&gt;1],其数组长度&gt;=2，并且向下取整的机制保证l+r&gt;&gt;1在 （l,r-1）内而不可能=x，故j!=r 证明j&gt;=l 当j&lt;l时 根据上面的推论 q[l,r]&lt;x恒成立，而x取自于（l，r)，故j&gt;=l","link":"/2021/04/30/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/"},{"title":"配置博客及图床","text":"主要内容： 腾讯云 chevereto 图床 typora配置 购买腾讯云服务器及域名腾讯云用于做图床服务器，如果使用github或者gitee或者其它第三方服务做图床，可以不使用。（配置选学生机最低档即可，106元一年） 购买域名用于映射xxxx.github.io, 更好记忆与访问，不需要可以不购买。（6元一年） 对域名申请ssl证书，用于部署图床的https访问。（免费，但安全等级不高，访问图床后端时还是会提示不安全） 部署chevereto傻瓜式的方法为安装宝塔，再根据步骤[1]安装chevereto即可，是社区访问还是个人使用请自行配置。默认配置为http访问，可以用于md文档的预览，但是在后续的部署上，个人博客网站为https访问，无法加载http资源的图床内容。所以需要在chevereto的设置栏中设置为https访问，以及将域名的ssl证书上传，配置nginx的https服务。 [1] ：https://blog.csdn.net/qq_44022113/article/details/114239677 Typora配置首先安装picgo[1]，用于后台的图片上传工作，在typora的偏好，图像中选择上传服务设定，选择Picgo以及配置相应的路径。 在picgo中安装chevereto插件，并将chevereto作为默认上传服务以及关闭其它服务，在图床设置中配置url以及key，key为chevereto的仪表盘中的api选项[2]，可以使用默认api的key或自己定义。 验证图片上传选项时请确保打开了chevereto的上传权限，以及打开图片重命名的选项保证同一图片上传不会发生同名错误。 因为申请的是域名申请到的ssl证书，所以请使用dns解析将网站转发到服务器上，再使用网站的接口而不是服务器的接口，否则图片将无法在typora中预览。（ssl证书是网站的而不是服务器的） 配置完后请重启typora保证设置生效。 [1] ： https://molunerfinn.com/PicGo/ [2]： https://YOUR_IP/dashboard/settings/api 2021-04-30 更新 后续使用时发现存在以下问题 域名需要备案 备案流程极其复杂，需要到公安局申请 网页上需要加注审核号以及相关信息 综上，放弃使用域名以及自建图床的方法，使用SM.MS图床（唯一缺点，上限5G,不过如果超了的话换一个账号好了），域名采用github.io一了百了。 hexo使用tips 生成文档使用hexo n “title” 部署文档使用hexo g -d 但是每次更新还要打开命令行，就非常的不人性化 解决方法 将hexo g -d 封装为bat脚本 //使用vps封装该bat脚本，因为.run里面有个参数0，可以让该bat脚本执行时不开启窗口 DIM objShell set objShell=wscript.createObject(&quot;wscript.shell&quot;) iReturn=objShell.Run(&quot;cmd.exe /C E:\\files\\GQ_BLOG\\update.bat&quot;, 0, TRUE) windows任务计划程序里设置执行该脚本的计划，每一小时一次（参数里记得加入起始位置为这两个脚本所在的目录）。 换电脑的时候记得把这个计划给删了，不然两端的内容不一致就van了","link":"/2021/03/12/%E9%85%8D%E7%BD%AE%E5%8D%9A%E5%AE%A2%E5%8F%8A%E5%9B%BE%E5%BA%8A/"},{"title":"21-03-学习","text":"主要内容： 学习 吴恩达 吴恩达逻辑回归 sigmoid 激活函数 将结果映射到0-1之间 ，hypothesis h(x)输出概率 决策边界 设置一个threshold 当概率大于t时预测为y=1,反之为0 当在sigmoid函数中设置为0.5时，只需要theta X大于0即预测为正例 线性边界： x1+x2+…+xn&gt;=1 非线性边界：x1^2 +x2^2+…+xn&gt;=1 代价函数 单纯使用平方代价函数会导致损失函数（因为sigmoid为非凸函数）变成非凸函数，使得损失函数有多个局部收敛点，希望能够尽量让损失函数只有一个收敛点。 解决方法 好处： 当样本y=1时，预测为0，损失为0，预测为1，损失为无穷 凸函数 简化代价函数和梯度下降 将上述的代价函数简写,和GAN网络的代价函数很像 y=0 时 1-y = 1反之亦然 梯度下降与线性回归中的类似，但是由于h（x）不是一个操作，所以并不等价 高级优化 一些高级的优化算法 选择合适的学习率，加快收敛速度 多元分类：一对多 上面讲的只是二分类，实际场景内有许多的类别需要我们来预测 ​ 1.Ova/r 对于n（n&gt;=3）个类训练n个分类器 将不属于该类的都归于负类 最后的输出结果为三个分类器中的最大值，最大值即为最终的分类 OvO 此时的结果为投票取最多的结果 n&gt;=3 OVO OVR 模型数目 n*(n-1)/2 n 时间 长 短 准确率 高 低 策略 选取所有分类器中最大次数预测结果 选取n个分类器中最大值对应的分类器的正值 分类器的不同 线性网络分类器 神经网络分类器 方法 二分类演化 softmax 效果 差（因为是线性，有局限） 好 正则化 过拟合问题 欠拟合：预测与真实有较大差距","link":"/2021/03/14/21-03-%E5%AD%A6%E4%B9%A0/"},{"title":"21-05-刷题","text":"主要内容： acwing，cpp基础 最小公倍数 = (a*b)/gcd(a,b) 1234567891011121314151617181920212223242526//辗转相除 递归int gcd(int a,int b){ if(a%b==0) return b; return gcd(b,a%b);}//非递归 可以加入判断大小swap()#include&lt;algorithm&gt;int gcd(int a,int b){ int tempt; while(a%b!=0){ tempt = a%b; a = b; b = tempt; } return b;}//双击666int gcd(int a,int b){ while(b^=a^=b^=a%=b); return a;}//(a*b)/gcd(a,b)int lcm(int a,int b){ return a*b/gcd(a,b);} 证明：最大公因数为相同质因子的乘积 最小公倍数为去除这部分质因子的部分乘积，两者相乘即为a*b 12345678a = a1*a2*m1*m2;b = b1*b2*b3*m1*m2*b4;//其中m1 和 m2为最小质因子的乘积，int gcd = (m1*m2);//而最小公倍数为 int lcm = a1*a2*b1*b2*b3*b4*(m1*m2)//故a*b == gcd*lcm; 最大公因数汇编代码分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#int a = a,int b = b参数的复制，不用作解释.LFB1573: .file 1 &quot;main.cpp&quot; .loc 1 4 21 .cfi_startproc pushq %rbp # .seh_pushreg %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp #, .seh_setframe %rbp, 0 .cfi_def_cfa_register 6 .seh_endprologue movl %ecx, 16(%rbp) # a, a movl %edx, 24(%rbp) # b, b.L3: # main.cpp:5: while(b^=a^=b^=a%=b); .loc 1 5 21 movl 16(%rbp), %eax # a, tmp94 cltd idivl 24(%rbp) # b movl %edx, 16(%rbp) # tmp95, a movl 16(%rbp), %eax # a, _6 # main.cpp:5: while(b^=a^=b^=a%=b); .loc 1 5 18 xorl %eax, 24(%rbp) # _6, b movl 24(%rbp), %eax # b, _8 # main.cpp:5: while(b^=a^=b^=a%=b); .loc 1 5 15 xorl %eax, 16(%rbp) # _8, a movl 16(%rbp), %eax # a, _10 # main.cpp:5: while(b^=a^=b^=a%=b); .loc 1 5 12 xorl %eax, 24(%rbp) # _10, b # main.cpp:5: while(b^=a^=b^=a%=b); .loc 1 5 23 cmpl $0, 24(%rbp) #, b setne %al #, retval.0_12 testb %al, %al # retval.0_12 je .L2 #, # main.cpp:5: while(b^=a^=b^=a%=b); .loc 1 5 5 jmp .L3 #.L2: # main.cpp:6: return a; .loc 1 6 12 movl 16(%rbp), %eax # a, _13 # main.cpp:7: } .loc 1 7 1 popq %rbp # .cfi_restore 6 .cfi_def_cfa 7, 8 ret .cfi_endproc cpp常用库函数都在里面 reverse将某一个范围内的元素倒序，o(n)，非常容易自己实现 123456789#include&lt;algorithm&gt;int a[] = {1,2,3,4,5};//从第二个元素开始reverse(a+1,a+5);//1 5 4 3 2vector&lt;int&gt; b({1,2,3,4,5});reverse(b.begin()+1,b.end());//1 5 4 3 2 random_shuffle随机打乱，需要结合ctime随机生成种子 123456789#include&lt;ctime&gt;#include&lt;algorithm&gt;//time(0)返回到1970年的秒数srand(time(0));int a[5] = {1,2,3,4,5};random_shuffle(a,a+5);vector&lt;int&gt; b({1,2,3,4,5});random_shuffle(b.begin(),b.end()); unique将对象中相同的元素放在前面，后面元素怎么排的不管，不一定能够保留下来，并返回最后一个元素的后一位的下标地址 12345678910111213#include&lt;algorithm&gt;//对于数组int a[] = {1,2,3,3,4,4,5};//输入为第一个元素的指针与最后一个元素结束的位置，a+1为第二个元素开始的位置、第一个元素结束的位置int m = unique(a,a+7)-a;//返回值为下标地址 [1,2,3,4,5,3,4]//对于vectorvector&lt;int&gt; b ({1,2,3,3,4,4,5});//int m = unique(b.begin(),b.end())-b.begin();//有效范围为（0，1，m-1）//或者直接删除后面一部分元素b.erase(unique(b.begin(),b.end()),b.end()); sort排序参数与random_shuffle一致，将左闭右开区间内的元素排序 1234567891011#include&lt;algorithm&gt; int a[] = {4,3,5,2,1};sort(a,a+5);vector&lt;int&gt; b({4,3,5,2,1});sort(b.begin(),b.end());vector&lt;int&gt; b({4,3,5,2,1});//从大到小排 数组也一样//默认就是从小到大排，所以没有smallersort(b.begin(),b.end(),greater&lt;int&gt;()); 重要的是如何自定义排序 123456bool cmp(int a,int b){//a是否应该 //当a出现在b前面时的条件 //从小到大 return a&lt;b;}sort(b.begin(),b.end(),cmp); 对结构体进行排序 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;ctime&gt;using namespace std;struct Rec{ int x,y; //也可以在此处重载&lt; (但是谁会这么无聊呢?}a[5];//自定义比较函数即可，没有比较函数时会报错的bool cmp(Rec a,Rec b){ return a.x&gt;b.x;}int main(){ for(int i=0;i&lt;5;i++){ a[i].x = i; a[i].y = -i; } for(int i=0;i&lt;5;i++)printf(&quot;(%d %d) &quot;,a[i].x,a[i].y); cout&lt;&lt;endl; sort(a,a+5,cmp); for(int i=0;i&lt;5;i++)printf(&quot;(%d %d) &quot;,a[i].x,a[i].y); cout&lt;&lt;endl;} lower_bound upper_bound二分查找对有序的数组或vector ，返回迭代器，对于数组即为返回指针 lower_bound 返回大于等于x的第一个元素的下标 upper_bound返回严格大于x的第一个元素的下标 123456789101112#include&lt;algorithm&gt;int a[] = {1,2,2,2,4,5,6};int p = lower_bound(a,a+7,2)-a;// p == 1int q = lower_bound(a,a+7,3)-a;//q == 4int n = upper_bound(a,a+7,2)-a;//n==4int m = upper_bound(a,a+7,4)-a;//m==5//vector同理，不作赘述 next_permutation 全排列返回给定list的全排列（字典序，list元素可重复），结果不重复 常用数据集结构vector12345678910111213141516171819202122232425262728#include&lt;vector&gt;vector&lt;int&gt; a;vector&lt;int&gt; a{1,2,3};int size = a.size();//需要注意它返回的的是unsign intcout&lt;&lt;a.size()-2&lt;&lt;endl;//18446744073709551615//所以在使用或者在循环里面，记得把它转成 intbool emp = a.empty()//False //迭代器 -&gt;指针//cpp中原则为左闭右开，所以end为最后一个元素后一个位置的起始地，所以需要减一cout&lt;&lt;*a.begin()&lt;&lt;endl;//1cout&lt;&lt;*(a.end()-1)&lt;&lt;endl;//3//vector长度cout&lt;&lt;a.end()-a.begin()&lt;&lt;endl;//3//最开始的元素，最后的元素cout&lt;&lt;a.front()&lt;&lt;endl;//1cout&lt;&lt;a.back()&lt;&lt;endl;//3//push_back pop_back ,pop不返回元素，只会删除最后一个元素，与python不一致a.push_back(4);int tempt = a.back();cout&lt;&lt;tempt&lt;&lt;endl;a.pop_back() queue123//循环队列//优先队列 默认大根堆 自定义小根堆 deque1 stack1 setmap如何对于struct重载运算符 1234567891011struct Data //本题实质是用结构体排序，需要重载小于符号{ int x; double y; string z; //需要关注const &amp; 从小到大排序 bool operator&lt; (const Data &amp;t) const { return x &lt; t.x; }}a[N]; acwing 68. 0到n-1中缺失的数字 比较经典的二分，不是很理解，虽然下面是自己写的 1234567891011121314class Solution {public: int getMissingNumber(vector&lt;int&gt;&amp; nums) { int l = 0,r = nums.size(); while(l&lt;r){ int mid = l+r&gt;&gt;1; if(nums[mid]&gt;mid)r = mid; else if(nums[mid]==mid) l = mid+1; else printf(&quot;nothing&quot;); } return l; }}; AcWing 51. 数字排列 leetcode 47. 全排列 II 比46题多了一个去重的部分，在第11行的后半段 y总的那个start变量不是很能理解，所以自己照着leetcode模板重新写了一份 12345678910111213141516171819202122232425262728293031323334class Solution {public: vector&lt;vector&lt;int&gt;&gt; res; vector&lt;int&gt; path; void dfs(vector&lt;int&gt;&amp; nums,int u,int state){ if(u==int(nums.size())){ res.push_back(path); return; } for(int i =0;i&lt;int(nums.size());i++){ //前一位用没用过都可以!(state&gt;&gt;(i-1)&amp;1)或者state&gt;&gt;(i-1)&amp;1,两个结果相同 //前者是前面的没选过的就跳过，更符合认知 for(int i =0;i&lt;int(nums.size());i++){ if(state&gt;&gt;i&amp;1||(i&gt;0&amp;&amp;nums[i]==nums[i-1]&amp;&amp;!(state&gt;&gt;(i-1)&amp;1)))continue; path[u] = nums[i]; dfs(nums,u+1,state+(1&lt;&lt;i)); } } return; } vector&lt;vector&lt;int&gt;&gt; permutation(vector&lt;int&gt;&amp; nums) { path = nums; sort(nums.begin(),nums.end()); dfs(nums,0,0); return res; // vector&lt;vector&lt;int&gt;&gt; ret; // //sor对于next_permutation比较重要，保证是所有的，即使用例里不包含这种情况 // sort(nums.begin(),nums.end()); // do{ // ret.push_back(nums); // }while(next_permutation(nums.begin(),nums.end())); // return ret; }}; cpp printf输出string printf %s 仅接受char* 的输入 12string s = &quot;abc&quot;;printf(&quot;%s&quot;,s.c_str()) 归并排序（非常严谨的nlogn） 确定分界点mid = l+r&gt;&gt;1 递归排序left_part，right_part 将两个数组合二为一（重点，双指针算法，将两个有序数组合并到一起，使用了On额外的空间） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051int li[100001];int tempt[100001];void merge_sort(int q[],int t[],int l,int r){ if(l&gt;=r)return; int mid = l+r&gt;&gt;1; merge_sort(q,t,l,mid);merge_sort(q,t,mid+1,r); for(int i=l;i&lt;=r;i++)t[i] = q[i]; int i = l,j = mid+1,idx = l; while(i&lt;=mid &amp;&amp; j&lt;=r){//这个花括号也可以不要，但是为了可读性，还是留在这里了 if(t[i]&lt;=t[j]) q[idx++] = t[i++]; else q[idx++] = t[j++]; } while(i&lt;=mid)q[idx++] = t[i++]; while(j&lt;=r)q[idx++] = t[j++];}//也可以直接把while塞到for里面，思路来源于算法第四版，非常的方便void merge_sort(int q[],int t[],int l,int r){ if(l&gt;=r)return; int mid = (l+r)&gt;&gt;1; merge_sort(q,t,l,mid);merge_sort(q,t,mid+1,r); for(int i=l;i&lt;=r;i++)t[i] = q[i]; int i = l,j = mid+1; for(int idx = l;idx&lt;=r;idx++){ if(i&gt;mid)q[idx] = t[j++]; else if(j&gt;r)q[idx] = t[i++]; else if(t[i]&lt;=t[j])q[idx] = t[i++]; else q[idx] = t[j++]; }}//o(1)做法，比较赛博朋克，思路可以扩宽到其它涉及到空间优化的地方//要求1：为正数，负数也行，加个abs，但是unsigned就不能用了//要求2：使用unsigned long long 因为，max*(max+1)会超过int上限//核心思想为，val%（max+1）为原数值，val/(max+1)为未来的数值unsigned long long li[100001];void merge_sort(unsigned long long q[],int l,int r){ if(l&gt;=r)return; int mid = l+r&gt;&gt;1; merge_sort(q,l,mid);merge_sort(q,mid+1,r); int max = q[l]; for(int i=l;i&lt;=r;i++)max = q[i]&gt;max?q[i]:max; int i = l,j = mid+1,idx = l; while(i&lt;=mid &amp;&amp; j&lt;=r){ if(q[i]%(max+1)&lt;=q[j]%(max+1)) q[idx++] += (q[i++]%(max+1))*(max+1); else q[idx++] += (q[j++]%(max+1))*(max+1); } while(i&lt;=mid) q[idx++] += (q[i++]%(max+1))*(max+1); while(j&lt;=r) q[idx++] += (q[j++]%(max+1))*(max+1); for(int i=l;i&lt;=r;i++)q[i]/=(max+1);} AcWing 789.数的范围 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int lower_bound(int li[],int n,int v){ int l = 0,r = n-1; int mid; while(l&lt;r){ mid = (l+r)&gt;&gt;1; if(li[mid]==v)r=mid; else if(li[mid]&lt;v)l = mid+1; else r = mid-1; } return li[l]==v?l:-1;}int upper_bound(int li[],int n,int v){ int l = 0,r = n-1; int mid; while(l&lt;r){ mid = (l+r+1)&gt;&gt;1;//上取整，考虑两个元素相同时的情况 if(li[mid]==v)l=mid;//同样考虑上取整 else if(li[mid]&lt;v)l = mid+1; else r = mid-1; } return li[l]==v?l:-1;} 多个背包，男人八题（楼天成） Acwing \\13. 找出数组中重复的数字 比较巧妙,涉及到多次的元素值交换 进阶 Leetcode287. 寻找重复数 acwing \\14. 不修改数组找出重复的数字 有单调性一定可以二分，可以二分不一定有单调性 二分的本质：具有边界性质，对于某一特征，左边满足，右边不满足 保留四位小数，区间就多2为六 浮点二分：当区间长度&lt;=1e-6时就不跳出循环，好处是不用考虑边界情况，非常的人性化，a+b/2一定介于两者之间而不会等于其中某一个数 12345678//具体差值看要求，x+2 保留4位小数，就区间长度为-6const double diff = 1e-6;while(r-l&gt;=diff){ //开平方 double mid = (l+r)/2; if(mid*mid&gt;=n)r = mid; else l = mid;} 也可以不用区间长度，直接循环100次、2^100次方精度还是很大的 12345for(int i=0;i&lt;100;i++){ double mid = (l+r)/2; if(mid*mid&gt;=n)r = mid; else l = mid;} 前缀和从1开始，比较人性化,不用做从1开始的特判 a1+…+an = sn-s0 Acwing \\796. 子矩阵的和 二维前缀和 对于图中的需求的黑色部分，f(x2,y2)为橙色方框，包含了它的上面以及左边一部分。所以减去绿色方框以及紫色方框，但是多减了一份橘色方框，所以还要加上一份橘色 foo(x2,y2,x1,y1) = f(x2,y2)-f(x2,y1-1)-f(x1-1,y2)+f(x1-1,y1-1) 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;const int N = 1010;int li[N][N];int get_sum(int x1,int y1,int x2,int y2){ //x1&lt;y1 x2&lt;y2 return li[x2][y2]-li[x2][y1-1]-li[x1-1][y2]+li[x1-1][y1-1]; }int main(){ int n,m,q; cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ scanf(&quot;%d&quot;,&amp;li[i][j]); li[i][j] += li[i-1][j]+li[i][j-1]-li[i-1][j-1]; } } for(int i=0;i&lt;q;i++){ int x1,y1,x2,y2; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2; cout&lt;&lt;get_sum(x1,y1,x2,y2)&lt;&lt;endl; }} Trie高效地完成字符串地存储与查找任务 12345678910111213141516171819202122232425int son[N][26],cnt[N],idx;//下标是0，是根节点，也是空节点//存储，插入void insert(char str[]){ int cur=0; for(int i =0;str[i];i++){ int u = str[i]-'a'; if(!son[cur][u])son[cur][u] = ++idx; cur = son[cur][u]; //为什么要对沿途地路径加一呢，因为后面要删除的时候要 cnt[cur]++; } }//查询int query(char str[]){ int cur =0; for(int i=0;str[i];i++){ int u = str[i]-'a'; //if(!son[cur][u])return 0; //同样是为了防止删除，虽然这题没有 if(!cnt[son[cur][u]])return 0; cur = son[cur][u]; } return cnt[cur];} Acwing\\3485. 最大异或和 Acwing算法时间分析：由数据范围反推算法复杂度以及算法内容 差分构建b数组 使得a数据是b数组的前缀和，而b是a的差分数组，两者是逆运算 ai = b1+..+bi 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//一维数据差分int n,m;int a[100010];int b[100010];int main(){ cin&gt;&gt;n&gt;&gt;m; //将离散的操作转为连续的操作为 差分 //将连续的操作转为离散的操作为 前缀 for(int i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;a[i]),b[i]=a[i]-a[i-1]; for(int i = 0;i&lt;m;i++){ int l,r,c; cin&gt;&gt;l&gt;&gt;r&gt;&gt;c; //对于l之后的数字都加上c //对于r+1之后的数组都减去c,保证只修改一个区间 b[l]+=c;b[r+1]-=c; } for(int i=1;i&lt;=n;i++)b[i]+=b[i-1],a[i]=b[i]; for(int i=1;i&lt;=n;i++)printf(&quot;%d &quot;,a[i]); cout&lt;&lt;endl; return 0;}//二维数组差分#include&lt;iostream&gt;using namespace std;int n,m,q;const int N = 1010;int a[N][N];int b[N][N];void insert(int x1,int y1,int x2,int y2,int c){ b[x1][y1]+=c;b[x1][y2+1]-=c; b[x2+1][y1]-=c;b[x2+1][y2+1]+=c;}int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;q; //导入 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++)scanf(&quot;%d&quot;,&amp;a[i][j]); } //差分初始化 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ insert(i,j,i,j,a[i][j]); } } //输入q个操作 for(int i=0;i&lt;q;i++){ int x1,y1,x2,y2,c; cin&gt;&gt;x1&gt;&gt;y1&gt;&gt;x2&gt;&gt;y2&gt;&gt;c; insert(x1,y1,x2,y2,c); } //前缀和 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ a[i][j] = a[i-1][j]+a[i][j-1]-a[i-1][j-1]+b[i][j]; } } //输出 for(int i=1;i&lt;=n;i++){ for(int j=1;j&lt;=m;j++){ cout&lt;&lt;a[i][j]&lt;&lt;&quot; &quot;; } cout&lt;&lt;endl; } return 0; } 对于（i,j）下标元素，该下边的二维前缀和表述为其最后的元素大小，根据其+c的特征，若其在修改的范围内，在(0-i)(0-j)的矩阵内的元素必存在一个+c,所以找出对应的其它三个元素位置即可 cpp将int转为str c++11标准增加了全局函数std::to_string: 12int a =123;string b = to_string(a); //数组不能用{-1}初始化，只能用{0}初始化 1234int a[100] = {-1};//错误#include&lt;cstring&gt;memset(a,-1,sizeof a)//正确int a[100] = {0} Acwing\\3510. 最长公共子序列 每日一题 题目非常的妙 首先将最长公共子序列转化为最长上升子序列，并使用二分贪心的方法求解最长上升子序列的长度，具体回来再看吧，今天的二分做的有点烂。 离散化整数，有序，离散化（值域较大，个数较少） 把值域从10^9映射到较小的区域（类似于哈希表） 原数组中可能有重复元素（去重，vector-&gt;erase-&gt;unique）） 1234vector&lt;int&gt; all;all.sort(all.begin(),all.end());//因为返回的是最后一个元素后面的一个元素的位置all.erase(unique(all.begin(),all.end()),all.end()); 如何算出a[i]映射后的数值（二分） 123456789101112//对于排序好的数组做映射，用二分将其映射到对应下标位置int find(int x){ int l = 0,r = all.size(); while(l&lt;r){ int mid = l+r&gt;&gt;1; if(all[mid]==x)return mid; else if(all[mid]&gt;x)r = mid-1; else l = mid+1; } return l;} AcWing 802. 区间和 重点是把所有的下标都放进来了，所以不用考虑一些下标位置。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;int n,m;//记录输入的n行 x cint x_in[100010];int c_in[100010];//因为这里总共有n+2m个数据，所以调整最大值，实际上我们存储的不仅仅是所有的x，还有所有的l rint new_arr[300030];//记录输入的m行 l rint l_in[100010];int r_in[100010];vector&lt;int&gt; all;int find(int x){ //不包含重复元素，直接返回下标加1即可，该元素一定存在（因为已经把它加到all里面了 //不过还是得复习一下lower_bound 和 upper_bound 感觉总是不会 int l = 0, r = all.size() - 1; while (l &lt; r) { int mid = l + r &gt;&gt; 1; if(all[mid] == x)return mid+1; else if(all[mid]&gt;x)r = mid -1; else l = mid+1; } return l+1;}int main(){ //数据读入，并且全部放到vector里面，为每一个输入的坐标确定离散后的下标 cin&gt;&gt;n&gt;&gt;m; for(int i=0;i&lt;n;i++){ scanf(&quot;%d %d&quot;,&amp;x_in[i],&amp;c_in[i]); all.push_back(x_in[i]); } for(int i =0;i&lt;m;i++){ int l,r; scanf(&quot;%d %d&quot;,&amp;l,&amp;r); l_in[i] = l; r_in[i] = r; //这里非常重要，否则会出现l和r不存在的情况，求这两个元素的下标就得分情况讨论 all.push_back(l);all.push_back(r); } //离散化 sort(all.begin(),all.end()); all.erase(unique(all.begin(),all.end()),all.end()); //离散化确定下标，且对于每一个x都+c for(int i=0;i&lt;n;i++){ new_arr[find(x_in[i])]+=c_in[i]; } //前缀和 for(int i=1;i&lt;=all.size();i++){ new_arr[i]+=new_arr[i-1]; } //直接求前缀和就行了 for(int i =0;i&lt;m;i++){ int l = find(l_in[i]),r = find(r_in[i]); //这里不用讨论l，r不在all里面出现的情况了 cout&lt;&lt;new_arr[r]-new_arr[l-1]&lt;&lt;endl; //否则如 1 3 7 //l==4 r ==5 //寻找后的下标都为2，非常难判断 } return 0;} （听说比较难懂，建议回来再看看） 异或运算符的优先级问题，因为异或的优先级比较低，所以会后运算，记得加上括号 取反的优先级比较高，如果是最后再计算取反记得加括号 AcWing 91. 最短Hamilton路径（比较难懂） 暴力做法是n!种排列组合，所以需要做状态压缩 重点是搞清楚 使用i来表示当前走过的路径（不记录顺序，因为我们不在乎之前走过的顺序是什么 i的遍历方式是从0001一直遍历到1111，虽然会出现0010这种无效解，所以（连接词破碎）需要判断j点是否有效（i&gt;&gt;j&amp;1)，这种遍历方式能保证1101在1111之前已经求解了 对1101这个状态来说f[1101][0],f[1101][2],f[1101][3]是有效的，其余都是无效的，我们分别对其中的每一个状态求解排除掉023后的上一个解 f +（li(20,30),li(02,32),li(30,32)）的最小值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int li[25][25];const int N = 20;const int max_state = 1&lt;&lt;20;//从 0 走到 jint f[max_state][N];int main(){ int n; cin&gt;&gt;n; for(int i =0;i&lt;n;i++){ for(int j =0;j&lt;n;j++){ scanf(&quot;%d&quot;,&amp;li[i][j]); } } memset(f,0x3f,sizeof f); f[1][0] = 0; for(int i =0;i&lt;1&lt;&lt;n;i++){ for(int j =0;j&lt;n;j++){ //从0 到 j 且 state为 i //判断i的合理性 即第j位为1 if(i&gt;&gt;j&amp;1){ //从k点 转移 至j点 for(int k=0;k&lt;n;k++){ //上一个点不能是j 且 k位为1 //因为i是从小到大排，所以删除某个点的这个状态一定已经计算过了 //if((i-(1&lt;&lt;j))&gt;&gt;k&amp;1) if(i&gt;&gt;k&amp;1&amp;&amp;k!=j){ f[i][j] = min(f[i][j],f[i-(1&lt;&lt;j)][k]+li[k][j]); } } } } } cout&lt;&lt;f[(1&lt;&lt;n)-1][n-1]&lt;&lt;endl; return 0; } 位移运算快速+这一位，虽然和state+(1&lt;&lt;u)是一样的，但是，雀食蟀","link":"/2021/05/01/21-05-%E5%88%B7%E9%A2%98/"},{"title":"21-06-刷题","text":"主要内容： acwing，tricks 求两个区间是否相交 123bool has_injection(int as,int ae,int bs,int be){ return max(as,bs)&lt;=min(ae,be);} AcWing 897. 最长公共子序列 基础实现还是很简单，注意dp[i-1][j-1] +1 不会小于dp[i-1][j]或dp[i][j-1]即可 因为题目中用的是二维数据，很容易的可以用一个tmp数组把o（n2）的空间压缩到o（n），但是还是多用了一个数组，其实可以滚动数组的方法，把它进一步压缩 具体实现细节： 假设f[i][j] = max(f[i-1][j],f[i][j-1],f[i-1][j-1]+1) 把它优化到O(N)后 没有修改的f[j]为f[i-1][j] j-1在j之前修改，修改前f[j-1]为f[i-1][j-1]，修改后f[j-1]为f[i][j-1] **故没有地方存放f[j-1][j-1]**，所以单独写一个upleft变量存放它，每次修改f[j-1]之前把它的值保存下来，使用完upleft后再把值覆盖到upleft中 12345#saving old f[j]int tmp = f[j-1];f[j] = max(f[j],f[j-1],upleft+1);#put old f[j] into upleftupleft = tmp; 1234567891011121314151617181920212223242526#LCS#include&lt;iostream&gt;using namespace std;int n,m;int dp[1010];int main(){ cin&gt;&gt;n&gt;&gt;m; string A,B; cin&gt;&gt;A&gt;&gt;B; for(int i =1;i&lt;=n;i++){ int upleft = 0; for(int j =1;j&lt;=m;j++){ //滚动dp int tmp = dp[j]; if(A[i-1]==B[j-1]){ dp[j] = max(dp[j],upleft+1) ; } else{ dp[j] = max(dp[j],dp[j-1]); } upleft = tmp; } } cout&lt;&lt;dp[m]&lt;&lt;endl; return 0;} tricks 如何将char型变量 ‘1’ 和 ‘0’ 做翻转 12345678910char c;if(c=='1') c =='0';else c =='1';//更加暴力的做法c^=1;//原理是 int('1') = 49 int('0') = 48//对1取异或，49末尾为1，所以为0，变为48//48末尾为0，所以变为1，变为49 如何将’a’与‘z’做翻转 12char c;c = 'a'+('z'-c); 定义二元组 123456789101112typedef pair&lt;int,int&gt; PII;auto ele = PII(1,2);//获取int x = ele.first,y = ele.second;//修改ele.first = 3;//二元组中加入数组typedef pair&lt;int*,int&gt; PARRI;int a[10];auto ele2 = PARRI(a,2);ele2.first[0] = -1; 如何求pai 123#include&lt;cmath&gt;double pi = acos(-1);//3.1415926535897932384626433832795028841971693993751058209749445923; 比较有意思的题目 \\97. 约数之和 步骤一，如何将一个数拆分为 a1^k1*a2^k2*a3^k3*an^kn的形式 123456int n = 1000000;for(int i =2;i&lt;=n;i++){ int s = 0; while(n%i==0)s++,n/=i; if(s)cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;endl;} 步骤二，如何表示一个数的所有约数的乘积 因为其中每一项中拿出一个数与其它项中拿一个数作乘积，可以保证不重不漏的表示出所有的约数 123/*(a1^0+a1^1+a1^2+..+a1^k1)*(a2^0+a2^1+a2^2+..+a2^k2)*(***)*(an^0+an^1+an^2+..+an^kn)*/ 步骤三，如何对通项公式求和 因为取mod运算的一致性不适用于除法，而除法的通项公式中需要用到除法，所以不能使用通项公式（但是可以结合数论的知识求解，这个我就不是很懂） 123456789101112131415161718/*如果k1 &amp; 1 == 1 ，假设为5 ，可以用二分的思想做拆分1 + a1^1 + a1^2 + a1^3 + a1^4 + a1^5=(1 + a1^1 + a1^2 ) * (1+ a1^2)因此可以用Log(n)的时间复杂度完成 on的求解如果为偶数，就加上最后一项当然也可以不加最后一项，假设为61 + a1^1 + a1^2 + a1^3 + a1^4 + a1^5 + a1^6=1 + a1 (1 + a1^1 + a1^2 + a1^3 + a1^4 + a1^5) */ 比较有意思的题 \\101. 最高的牛 重点在于，由于大于的传递性，两头牛线段之间的所有数都要下降一位。 123456//使用set去重#include&lt;set&gt;set&lt;pair&lt;int,int&gt;&gt; existed;if(!existed.count({a,b})){ existed.insert({a,b});} 二元list排序 (li1,li2)，当li2不同时按照li2排序，否则按照li1排序 1234567bool cmp(vector&lt;int&gt; a,vector&lt;int&gt; b){//a是否应该 //当a出现在b前面时的条件 //从小到大 if(a[1]!=b[1])return a[1]&lt;b[1]; else return a[0]&lt;b[0]; } a+b&gt;&gt;1 越int界限 12345//a+b有可能超过int 上限int c = a+b&gt;&gt;1;//b&gt;aint d = a + (b-a&gt;&gt;1) 对map作遍历操作 （以及map 中int的默认default值为0） 12345678map&lt;int,int&gt; m;m[-1]++;m[1]++;m[1]++;//返回的是&lt;int,int&gt;(取决于定义的m)的pairfor(auto k:m){ cout&lt;&lt;k.first&lt;&lt;&quot; &quot;&lt;&lt;k.second&lt;&lt;endl;} bool表达式除了0 这个数值，其它的都是true（fuck） cpp类成员的赋值 123456789//初始化函数//加冒号的是构造函数的初始化列表A(string kingName):king(kingName){ king = kingName //在内部直接引用。 //如果同名字怎么办呢？}private:string king; 对string重新设计大小 可以用于最小长度的返回值结果的初始化 1234string a = &quot;a&quot;;//a.size()==1;a.resize(16);//a.size()==16 初始化二维vector时确定其二维大小 12345vector&lt;vector&lt;int&gt;&gt; pre(mat.size()+1,vector&lt;int&gt; (mat[0].size()+1));//因为初始化vector时,参数列表为vector(int size)vector(int size,&lt;T&gt; t)//这个时候可以对t进行修改编辑，即可确定二维数组的大小了 cpp求给定范围内的随机数参考 1234567#include&lt;ctime&gt;srand(time(0));//对[a,b]来说//偏移量为（0-（b-a））故对b-a+1取余int idx = rand()%(b-a+1)+a; 如果一次遍历求数组中最大和第二大的值 1234567891011int a = -1;//比最小的小即可int b = -1;for(auto num:nums){ if(num&gt;a){ b = a; a = num; } else{ b = max(b,num); }} cpp节省运行时间小技巧 加&amp;,传递真实地址而不是拷贝一份 for(auto v: li) 改为 for(&lt;T&gt; v:li) 1234567void dfs(vector&lt;string&gt;&amp; cur,int idx,int n,string&amp; s){ //foo()}for(int v:li){ //foo()}","link":"/2021/06/01/21-06-%E5%88%B7%E9%A2%98/"},{"title":"21-06-学习","text":"主要内容： 智能计算的初步了解 主要的期刊 Evolutionary computation CCFB https://dblp.uni-trier.de/db/journals/tec/index.html http://dblp.uni-trier.de/db/journals/ec/ Fuzzy sets Neural Networks Systems，Man and Cybernetics ML Complex Systems AI 主要的会议 computational Intelligence(WCCI) Evolutionary computation(CEC) **Systems，Man and Cybernetics(SMC) ** CCFC https://dblp.uni-trier.de/db/conf/smc/ Genetic and Evolutionary computation(GECCO) CCFC http://dblp.uni-trier.de/db/conf/gecco/ Ant Colony Optimization and Swarm Intelligence(ANTS) Simulated Evolution And Learning(SEAL) ICGA FOGA/CS GPC CSCWD CCFC http://dblp.uni-trier.de/db/conf/cscwd/ d","link":"/2021/06/01/21-06-%E5%AD%A6%E4%B9%A0/"},{"title":"我的大学四年","text":"主要内容： 记录我的大学四年生活，以及一些个人感悟 大一 大二 劣势、选择、坚持大三 大四 变故、承诺、未来","link":"/2021/06/11/%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E5%9B%9B%E5%B9%B4/"},{"title":"checklist_always","text":"主要内容： 需要完成的代码学习，已经完成的代码学习 小项目： MIT 6.S081 （和828差不多，属于OS，入手平滑） 官方地址https://pdos.csail.mit.edu/6.828/2020/xv6.html MIT 6.828（属于研究性质课程，资料较少） 暂时先不学 MIT 6.830 （数据库）","link":"/2021/06/17/checklist-always/"},{"title":"MIT-6.S081","text":"主要内容： 6.s081的学习以及实验配置 学习实验实验环境安装参照 https://pdos.csail.mit.edu/6.828/2020/labs/util.html 启动环境 sudo make qemu 关闭环境 先按ctrl+a 松手 ，再按x","link":"/2021/06/19/MIT-6-S081/"},{"title":"21-07-浮生物语","text":"主要内容： 带学毕业的暑假日常更新 07-18日常更新其实回家了就刷题刷的不是很认真，所以刷题也没更新，人又懒所以浮生物语到现在才来写，现在来写主要也是想要记录一下有意思的事情。 上个周末在路上碰到了熊老师，然后就被邀请回他们班做宣讲去了，所以上周一直在准备这件事情（其实也没准备什么，反而是越拖越烦），到最后准备的稿子也没有派上用场。 其实总共准备了有两面的A4纸，后面一面的还是网上copy来的心灵鸡汤。srds，这个鸡汤也不是常规的鸡汤，反正也比较符合我当时的心情哈。但是最后讲的东西，这些鸡汤也完全没有用到，只讲了可能不到半页纸的内容吧，因为确实高考这玩意，考得好不好完全靠自己有没有意识到自己其实有能力考一个211起步的学校，以及考一个高水平学校的必要性。 总的来说学弟学妹们还是蛮捧场的，所以本来觉得10分钟足够的内容讲了一个小时都有点意犹未尽。以开始还有点小紧张的来着，说着说着兴致就上来了。感觉在很多人面前说话也是一种本领，只是我现在不具备（之前也不具备）。看着台下一张张16岁的脸，突然感觉青葱岁月一下子就过去了，总有有人18岁，但没有人永远18岁。 然后晚上和班主任和英语老师和两个20届的学弟吃了个饭。不由得感叹时间流逝的速度，一下子我就成为传说中的学长了，555。晚上也聊了些有意思的事情，","link":"/2021/07/18/21-07-%E6%B5%AE%E7%94%9F%E7%89%A9%E8%AF%AD/"}],"tags":[{"name":"技术","slug":"技术","link":"/tags/%E6%8A%80%E6%9C%AF/"},{"name":"学习","slug":"学习","link":"/tags/%E5%AD%A6%E4%B9%A0/"},{"name":"网课","slug":"网课","link":"/tags/%E7%BD%91%E8%AF%BE/"},{"name":"吴恩达","slug":"吴恩达","link":"/tags/%E5%90%B4%E6%81%A9%E8%BE%BE/"},{"name":"刷题","slug":"刷题","link":"/tags/%E5%88%B7%E9%A2%98/"},{"name":"acwing","slug":"acwing","link":"/tags/acwing/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"经典算法","slug":"经典算法","link":"/tags/%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95/"},{"name":"智能计算","slug":"智能计算","link":"/tags/%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97/"},{"name":"论文","slug":"论文","link":"/tags/%E8%AE%BA%E6%96%87/"},{"name":"日常","slug":"日常","link":"/tags/%E6%97%A5%E5%B8%B8/"},{"name":"后端","slug":"后端","link":"/tags/%E5%90%8E%E7%AB%AF/"},{"name":"MIT","slug":"MIT","link":"/tags/MIT/"}],"categories":[{"name":"技术","slug":"技术","link":"/categories/%E6%8A%80%E6%9C%AF/"},{"name":"学习","slug":"学习","link":"/categories/%E5%AD%A6%E4%B9%A0/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"浮生物语","slug":"浮生物语","link":"/categories/%E6%B5%AE%E7%94%9F%E7%89%A9%E8%AF%AD/"}]}